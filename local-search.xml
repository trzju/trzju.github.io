<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++ 基础知识</title>
    <link href="/2026/02/09/C++Basics/"/>
    <url>/2026/02/09/C++Basics/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>本文涵盖了 C++ 学习过程中的核心知识点整理，包括拷贝控制、多态的底层实现、内存管理细节以及多线程编程的基础。部分章节仍需补充（标记为 TODO），作为后续深入学习的索引。</p><hr><h1>第一部分：对象生命周期与特殊成员函数</h1><h2 id="%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E3%80%81%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%88%87%E7%89%87" id="拷贝构造、赋值构造与对象切片">拷贝构造、赋值构造与对象切片 <a class="header-anchor" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E3%80%81%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%88%87%E7%89%87">#</a></h2><p>在 C++ 中，<strong>拷贝构造函数（Copy Constructor）</strong> 和 <strong>赋值构造函数（Copy Assignment Operator）</strong> 都是用于对象复制的特殊成员函数，但它们的使用场景和语义不同，容易混淆。</p><p>✅ 一句话区分：</p><table><thead><tr><th style="text-align:left">场景</th><th style="text-align:left">调用函数</th></tr></thead><tbody><tr><td style="text-align:left">用一个已有对象<strong>初始化一个新对象</strong></td><td style="text-align:left"><strong>拷贝构造函数</strong></td></tr><tr><td style="text-align:left">用一个已有对象<strong>给另一个已存在的对象赋值</strong></td><td style="text-align:left"><strong>赋值构造函数（赋值运算符）</strong></td></tr></tbody></table><h3 id="%E4%B8%80%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88copy-constructor%EF%BC%89" id="一、拷贝构造函数（Copy-Constructor）">一、拷贝构造函数（Copy Constructor） <a class="header-anchor" href="#%E4%B8%80%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88copy-constructor%EF%BC%89">#</a></h3><p>📌 定义格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">ClassName</span>(<span class="hljs-type">const</span> ClassName&amp; other);<br></code></pre></td></tr></table></figure><p>必须用引用传参，不可以用值传递**（防止递归引用）**</p><p>📌 触发时机：</p><ul><li><p>用一个对象初始化另一个新对象时：</p><p>C++</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">MyClass a<span class="hljs-comment">;</span><br>MyClass b <span class="hljs-operator">=</span> a<span class="hljs-comment">;        // ✅ 拷贝构造</span><br>MyClass c(a)<span class="hljs-comment">;         // ✅ 拷贝构造</span><br></code></pre></td></tr></table></figure></li><li><p>函数传参<strong>按值传递</strong>时：</p><p>C++</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(MyClass obj)</span></span>; <span class="hljs-comment">// ✅ 调用拷贝构造</span><br></code></pre></td></tr></table></figure></li><li><p>函数返回对象<strong>按值返回</strong>时（未优化前）：</p><p>C++</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">MyClass <span class="hljs-title">create</span>()</span> &#123;<br>    MyClass temp;<br>    <span class="hljs-keyword">return</span> temp; <span class="hljs-comment">// ✅ 可能调用拷贝构造（NRVO 可能优化掉）</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="todo%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%A8%E6%80%81%E6%88%90%E5%91%98" id="TODO：深拷贝与浅拷贝，默认拷贝构造函数-对象的动态成员">TODO：深拷贝与浅拷贝，默认拷贝构造函数-对象的动态成员 <a class="header-anchor" href="#todo%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%A8%E6%80%81%E6%88%90%E5%91%98">#</a></h4><h3 id="%E4%BA%8C%E3%80%81%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88copy-assignment-operator%EF%BC%89" id="二、赋值构造函数（Copy-Assignment-Operator）">二、赋值构造函数（Copy Assignment Operator） <a class="header-anchor" href="#%E4%BA%8C%E3%80%81%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88copy-assignment-operator%EF%BC%89">#</a></h3><p>📌 定义格式：</p><p>C++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ClassName&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ClassName&amp; other);<br></code></pre></td></tr></table></figure><p>📌 触发时机：</p><ul><li><p>用一个已有对象给另一个<strong>已存在的对象</strong>赋值时：</p><p>C++</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">MyClass a<span class="hljs-comment">;</span><br>MyClass b<span class="hljs-comment">;</span><br><span class="hljs-attribute">b</span> <span class="hljs-operator">=</span> a<span class="hljs-comment">; // ✅ 调用赋值运算符</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="%E4%B8%89%E3%80%81%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93%E8%A1%A8" id="三、对比总结表">三、对比总结表 <a class="header-anchor" href="#%E4%B8%89%E3%80%81%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93%E8%A1%A8">#</a></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>拷贝构造函数</strong></th><th><strong>赋值运算符</strong></th></tr></thead><tbody><tr><td>用途</td><td>初始化新对象</td><td>给已有对象赋值</td></tr><tr><td>形式</td><td><code>ClassName(const ClassName&amp;)</code></td><td><code>ClassName&amp; operator=(const ClassName&amp;)</code></td></tr><tr><td>触发</td><td>初始化、传值、返回值</td><td>赋值操作</td></tr><tr><td>返回值</td><td>无（构造函数）</td><td><code>*this</code>（支持链式赋值）</td></tr></tbody></table><hr><h3 id="%E5%9B%9B%E3%80%81%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%AF%B9%E6%AF%94" id="四、示例代码对比">四、示例代码对比 <a class="header-anchor" href="#%E5%9B%9B%E3%80%81%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%AF%B9%E6%AF%94">#</a></h3><p>C++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v = <span class="hljs-number">0</span>) : <span class="hljs-built_in">value</span>(v) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Constructor\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; other) : <span class="hljs-built_in">value</span>(other.value) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Copy Constructor\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 赋值运算符</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            value = other.value;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Copy Assignment Operator\n&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;     <span class="hljs-comment">// Constructor</span><br>    MyClass b = a;     <span class="hljs-comment">// Copy Constructor（初始化）</span><br>    MyClass c;<br>    c = a;             <span class="hljs-comment">// Copy Assignment Operator（赋值）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>✅ 输出：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">Constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Copy</span> <span class="hljs-title">Constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Copy</span> <span class="hljs-title">Assignment</span> <span class="hljs-title">Operator</span></span><br></code></pre></td></tr></table></figure><ul><li>如果你定义了<strong>析构函数、拷贝构造、拷贝赋值</strong>中的一个，<strong>建议三者都定义</strong>（Rule of Three）。</li><li>C++11 起，还有<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>（Rule of Five）。</li></ul><h2 id="%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E3%80%81%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0" id="深拷贝、浅拷贝与拷贝构造、赋值构造">深拷贝、浅拷贝与拷贝构造、赋值构造 <a class="header-anchor" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E3%80%81%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0">#</a></h2><p><em>(此处待补充)</em></p><h2 id="%E5%AF%B9%E8%B1%A1%E5%88%87%E7%89%87-(object-slicing)" id="对象切片-Object-Slicing">对象切片 (Object Slicing) <a class="header-anchor" href="#%E5%AF%B9%E8%B1%A1%E5%88%87%E7%89%87-(object-slicing)">#</a></h2><p><strong>拷贝构造/赋值构造与多态之间</strong>并不是“协同工作”的关系，而是<strong>存在潜在冲突</strong>的。</p><p><strong>它们默认都是“非虚”的，一旦用于多态场景，就会把对象切成“基类子对象”，从而丢失派生类信息——这几乎总是 bug</strong>。</p><p><a href="https://juejin.cn/post/7547891478565011508">深入理解C++对象切片（Object Slicing）：从 benign bug 到 dangerous corruption</a></p><p>C++ Primer 第5版 15.2.3 ……在对象之间不存在类型转换 page.535</p><p><strong>TODO</strong></p><blockquote><p>关于对象切片 我的理解：根本就是因为C++的默认拷贝/赋值/移动 构造函数是<strong>非虚</strong>的，是不支持多态的，是静态绑定而非运行时动态绑定的。</p><p>始终牢记C++默认采用静态绑定和非虚赋值操作，并通过使用指针、引用、智能指针和谨慎的类设计来规避这一陷阱。</p></blockquote><h3 id="%E8%AD%A6%E6%83%95%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%B9%E5%99%A8" id="警惕标准库容器">警惕标准库容器 <a class="header-anchor" href="#%E8%AD%A6%E6%83%95%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%B9%E5%99%A8">#</a></h3><p>将派生类对象直接存入<code>std::vector&lt;Base&gt;</code>会发生<strong>切片</strong>。</p><p>正确做法是使用<code>std::vector&lt;std::unique_ptr&lt;Base&gt;&gt;</code>。</p><hr><h1>第二部分：深入多态与继承</h1><h2 id="%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%EF%BC%8C%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81" id="构造与析构，继承与多态">构造与析构，继承与多态 <a class="header-anchor" href="#%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%EF%BC%8C%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81">#</a></h2><h3 id="1.-%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F" id="1-构造顺序">1. 构造顺序 <a class="header-anchor" href="#1.-%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F">#</a></h3><p>构造的顺序永远是从基类到派生类逐级构造，这是语法规则，与多态无关。</p><blockquote><p><strong>对象构造的完整流程</strong>：</p><ol><li><strong>分配对象内存</strong></li><li><strong>执行父类构造（如果有）</strong></li><li><strong>执行成员初始化列表 - 按声明顺序初始化所有成员 - 未在列表中的成员使用默认初始化</strong></li><li><strong>执行构造函数体</strong></li></ol></blockquote><h4 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%EF%BC%9A" id="初始化列表：">初始化列表： <a class="header-anchor" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%EF%BC%9A">#</a></h4><p>初始化列表并不决定各成员变量的初始化顺序，实际的初始化顺序由成员变量的声明顺序决定。因此初始化列表的顺序最好保持与声明顺序一致。</p><p><strong>初始化≠赋值</strong>：初始化列表是真正的初始化，构造函数体内是赋值。</p><p>无论是否有初始化列表、无论成员变量是否在初始化列表中，都会在进入构造函数体前进行初始化。</p><p>——<strong>因此</strong>：存在以下四种必须使用初始化列表的情况：<code>const</code>成员变量；引用成员变量；没有默认构造函数的类成员；父类构造函数调用。</p><p><strong>在C++中，初始化总是优于赋值</strong>，对于类类型，直接初始化比默认构造+赋值更高效、更快。</p><blockquote><p><strong>最佳实践：</strong></p><ol><li><strong>总是使用初始化列表</strong></li><li><strong>保持初始化顺序与声明顺序一致</strong></li><li><strong>基本类型也要初始化</strong></li></ol></blockquote><h4 id="%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F%E6%98%AF%E9%9D%99%E6%80%81%E8%A7%84%E5%88%99%E3%80%82" id="构造顺序是静态规则。"><strong>构造顺序是静态规则</strong>。 <a class="header-anchor" href="#%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F%E6%98%AF%E9%9D%99%E6%80%81%E8%A7%84%E5%88%99%E3%80%82">#</a></h4><p>因为派生类的对象里“包含”一个基类子对象，必须先构造好基类部分，才能继续构造派生类部分。</p><p>编译器在派生类构造函数体执行之前自动插入基类构造函数的调用。</p><p>编译器会在派生类构造函数的<strong>初始化阶段</strong>（而非构造函数体内部的开头）自动插入基类构造函数的调用代码。</p><p>C++ 语言规则强制要求：<strong>派生类对象的构造必须先初始化其继承的基类部分，再初始化派生类自身的成员和构造函数体</strong>。这一规则由编译器通过以下方式在编译时落实：</p><ol><li><strong>隐式调用场景</strong>：如果派生类构造函数没有显式指定基类构造函数（即初始化列表中未写基类名），编译器会自动插入<strong>基类的默认构造函数（无参构造）</strong> 调用，且该调用发生在：<ul><li>派生类自身成员的初始化之前；</li><li>派生类构造函数体执行之前。</li></ul></li><li><strong>显式调用场景</strong>：如果派生类构造函数在<strong>初始化列表</strong>中显式指定了基类构造函数（含带参构造），编译器会按指定的构造函数调用，且顺序仍优先于派生类成员初始化和构造函数体。</li></ol><p>构造函数的执行分为两个阶段：</p><ul><li><strong>初始化阶段</strong>：先执行基类构造 → 再执行派生类成员的初始化（按成员声明顺序，而非初始化列表顺序）；</li><li><strong>函数体阶段</strong>：执行派生类构造函数体内的代码。</li></ul><p>编译器的处理是：在<strong>初始化阶段</strong>的最开始，自动生成基类构造函数的调用代码（隐式或显式），而非修改构造函数体。</p><h4 id="%E2%80%93%3E%3E-%E6%89%80%E4%BB%A5%E5%A6%82%E6%9E%9C%E5%9F%BA%E7%B1%BB%E6%B2%A1%E6%9C%89%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E4%BB%85%E5%90%AB%E5%B8%A6%E5%8F%82%E6%9E%84%E9%80%A0%EF%BC%89%EF%BC%8C%E4%B8%94%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9C%AA%E6%98%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E5%9F%BA%E7%B1%BB%E5%B8%A6%E5%8F%82%E6%9E%84%E9%80%A0%EF%BC%8C%E7%BC%96%E8%AF%91%E4%BC%9A%E7%9B%B4%E6%8E%A5%E6%8A%A5%E9%94%99%EF%BC%8C-%E8%BF%99%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AF%81%E6%98%8E%E5%9F%BA%E7%B1%BB%E6%9E%84%E9%80%A0%E7%9A%84%E8%B0%83%E7%94%A8%E6%98%AF%E7%BC%96%E8%AF%91%E6%9C%9F%E5%BC%BA%E5%88%B6%E6%A3%80%E6%9F%A5%E5%92%8C%E5%A4%84%E7%90%86%E7%9A%84" id="–-所以如果基类没有默认构造函数（仅含带参构造），且派生类未显式调用基类带参构造，编译会直接报错，-这进一步证明基类构造的调用是编译期强制检查和处理的">–&gt;&gt; 所以如果基类没有默认构造函数（仅含带参构造），且派生类未显式调用基类带参构造，<strong>编译会直接报错</strong>， 这进一步证明基类构造的调用是编译期强制检查和处理的 <a class="header-anchor" href="#%E2%80%93%3E%3E-%E6%89%80%E4%BB%A5%E5%A6%82%E6%9E%9C%E5%9F%BA%E7%B1%BB%E6%B2%A1%E6%9C%89%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E4%BB%85%E5%90%AB%E5%B8%A6%E5%8F%82%E6%9E%84%E9%80%A0%EF%BC%89%EF%BC%8C%E4%B8%94%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9C%AA%E6%98%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E5%9F%BA%E7%B1%BB%E5%B8%A6%E5%8F%82%E6%9E%84%E9%80%A0%EF%BC%8C%E7%BC%96%E8%AF%91%E4%BC%9A%E7%9B%B4%E6%8E%A5%E6%8A%A5%E9%94%99%EF%BC%8C-%E8%BF%99%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AF%81%E6%98%8E%E5%9F%BA%E7%B1%BB%E6%9E%84%E9%80%A0%E7%9A%84%E8%B0%83%E7%94%A8%E6%98%AF%E7%BC%96%E8%AF%91%E6%9C%9F%E5%BC%BA%E5%88%B6%E6%A3%80%E6%9F%A5%E5%92%8C%E5%A4%84%E7%90%86%E7%9A%84">#</a></h4><h3 id="2.-%E5%9F%BA%E7%B1%BB%E8%99%9A%E6%9E%90%E6%9E%84%E4%B8%8E%E5%A4%9A%E6%80%81" id="2-基类虚析构与多态">2. 基类虚析构与多态 <a class="header-anchor" href="#2.-%E5%9F%BA%E7%B1%BB%E8%99%9A%E6%9E%90%E6%9E%84%E4%B8%8E%E5%A4%9A%E6%80%81">#</a></h3><p>首先，<strong>语言规定</strong>：无论析构函数从哪一层开始执行，必须保证所有基类的析构函数也被调用</p><p>当基类的析构函数为virtual时，<code>delete base_ptr</code>触发<strong>动态绑定</strong>，运行时根据实际的<strong>对象</strong>类型找到对应的析构函数。</p><p>即<strong>virtual</strong>决定了从哪一层开始析构。</p><p>析构的执行顺序：<strong>派生类析构函数体 → 派生类自身*成员*的析构 → 基类析构函数体</strong></p><p>编译派生类析构函数时，编译器会在其 <strong>“清理阶段”</strong>（派生类析构函数体执行完毕后），自动插入基类析构函数的调用代码 —— 无需手动编写 <code>Base::~Base()</code>，编译期已确定这一调用逻辑（类似构造函数，但顺序相反）。</p><h4 id="why-virtual-destructor" id="Why-virtual-destructor">Why virtual destructor <a class="header-anchor" href="#why-virtual-destructor">#</a></h4><p>虚函数是C++多态的实现，没有虚函数就没有多态。</p><p>那么基类的析构函数不是虚析构时，在析构子类时就无法实现<strong>多态</strong>，即无法正确地先调用子类析构再调用基类析构，而是直接调用基类析构，导致子类资源未正确释放。</p><p><em>(此处省略原笔记中的代码示例，保留原意)</em></p><blockquote><p><strong>结论</strong>：将基类的析构函数定义为虚函数后，<code>delete base_ptr</code> 才能得到正确的运行结果（先派生类析构，后基类析构）。</p></blockquote><h4 id="%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5" id="虚析构函数的工程实践">虚析构函数的工程实践 <a class="header-anchor" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5">#</a></h4><p>在工程实践中，C++ 的虚析构函数是一条**“只要类可能被继承，就默认应声明为虚”<strong>的防御性编程铁律。它的核心目的不是“为了多态调用”，而是</strong>“为了在用户通过基类指针 delete 派生对象时，能够按构造逆序完整执行整条析构链，避免资源泄漏+未定义行为”**。</p><p><strong>工业级代码套路：</strong></p><ol><li><strong>基类模板</strong>：声明 <code>virtual ~Base() = default;</code> 并禁用拷贝（防止切片）。</li><li><strong>抽象接口</strong>：声明纯虚析构 <code>virtual ~ILogger() = 0;</code> 并在 .cpp 给出空实现。</li><li><strong>工程规范</strong>：“凡是设计为被继承的类，立即把析构函数声明为 <code>virtual</code>（或纯虚 + 定义），并关闭拷贝；否则就在类注释里写 ‘本类禁止继承’ 并加 <code>final</code>。”</li></ol><h3 id="3.-%E8%99%9A%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF" id="3-虚继承，多重继承">3. 虚继承，多重继承 <a class="header-anchor" href="#3.-%E8%99%9A%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF">#</a></h3><p>首先是<strong>多继承</strong>可能带来的问题（要我说就不应该写多继承）：</p><p>比如菱形继承，很可能导致命名冲突、冗余数据等问题。</p><p>为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。</p><p>C++标准库中的 <code>iostream</code> 类就是一个虚继承的实际应用案例（继承自 <code>istream</code> 和 <code>ostream</code>，它们又共同继承自 <code>base_ios</code>）。</p><h2 id="%E8%AF%A6%E8%AF%B4%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81" id="详说继承与多态">详说继承与多态 <a class="header-anchor" href="#%E8%AF%A6%E8%AF%B4%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81">#</a></h2><p>什么是多态？OOP的核心思想就是多态性。</p><p><strong>OOP-派生类与继承类之间的类型转换</strong>：使用动态绑定（运行时绑定），可以在一定程度上忽略相似类型的区别，而以统一的方式使用他们的对象。——这也是为什么要使用基类指针、引用来操作派生类对象。</p><h3 id="why-override" id="Why-override">Why override <a class="header-anchor" href="#why-override">#</a></h3><p><code>override</code> 是 C++11 引入的一个上下文关键字，用于<strong>显式地</strong>指出一个成员函数是重写基类的虚函数。它的作用是<strong>帮助编译器检查是否真的重写了基类的虚函数</strong>，从而避免因为拼写错误、参数列表不一致等问题导致的“<strong>隐藏</strong>”而非“<strong>重写</strong>”的情况。</p><p>Simple as that!</p><blockquote><p><strong>override关键字不可以用于重写基类的普通成员函数</strong>。在 C++ 中，<code>override</code> <strong>只能用于重写基类的虚函数（<code>virtual</code>）</strong>。</p></blockquote><h3 id="%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8" id="虚函数表">虚函数表 <a class="header-anchor" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8">#</a></h3><p>基类的虚函数和派生类的对应虚函数一定在虚函数表里槽号相等。</p><p>虚函数表是一个“<strong>以基类为模板</strong>”的线性数组。</p><ul><li>编译器先给基类 <code>Base</code> 生成一张表，按<strong>声明顺序</strong>把每个虚函数地址依次放进槽 0、1、2…</li><li>再给派生类 <code>Derived</code> 生成一张表，<strong>先逐字复制基类那张表</strong>（保持槽号不变），然后把<strong>被重写的那几项就地覆盖</strong>成 <code>Derived</code> 的新地址；新增虚函数往后追加。</li></ul><p>多态的实现：<strong>对象里取 vptr → 查类虚表 → 得到最终函数地址</strong>。</p><h3 id="%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB" id="纯虚函数与抽象类">纯虚函数与抽象类 <a class="header-anchor" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB">#</a></h3><p>只要类中有一个纯虚函数，它就是抽象类，不能被实例化。即使是只有析构函数被定义为纯虚函数也是抽象类。（纯析构函数比较特殊，必须提供定义–<strong>可以是空实现</strong>）</p><h3 id="%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E3%80%81%E9%9A%90%E8%97%8F%E4%B8%8E%E8%A6%86%E7%9B%96" id="函数重载、隐藏与覆盖">函数重载、隐藏与覆盖 <a class="header-anchor" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E3%80%81%E9%9A%90%E8%97%8F%E4%B8%8E%E8%A6%86%E7%9B%96">#</a></h3><ol><li><strong>重载 (Overload)</strong>：同一作用域，同名不同参。</li><li><strong>隐藏 (Hiding)</strong>：<ul><li>派生类定义了与基类同名的成员（无论参数是否一致），基类成员被隐藏。</li><li><strong>警惕</strong>：如果派生类 <code>override</code> 的虚函数参数列表与基类不同，那么<strong>不能构成</strong> <code>override</code>，而是构成了<strong>隐藏</strong>。</li></ul></li><li><strong>覆盖 (Override)</strong>：派生类重写基类的虚函数，签名必须完全匹配。</li></ol><p><em>(关于名字查找与继承的详细解析，见原文档中的“函数调用的解析过程”章节)</em></p><hr><h1>第三部分：高级语言特性 (RTTI, Template, Keywords)</h1><h2 id="rtti-(run-time-type-identification)" id="RTTI-Run-Time-Type-Identification">RTTI (Run-Time Type Identification) <a class="header-anchor" href="#rtti-(run-time-type-identification)">#</a></h2><p>C++有3个支持RTTI的元素：</p><ol><li><code>dynamic_cast</code>：安全地将基类指针转换为派生类指针（如果失败返回0/nullptr）。</li><li><code>typeid</code>：返回对象的类型信息。</li><li><code>type_info</code>：存储类型信息。</li></ol><p>⚠️<strong>RTTI只适用于包含虚函数的类</strong>。</p><h3 id="dynamic_cast-%E6%9C%BA%E5%88%B6" id="dynamic-cast-机制">dynamic_cast 机制 <a class="header-anchor" href="#dynamic_cast-%E6%9C%BA%E5%88%B6">#</a></h3><p><strong>交叉转换是否成功，取决于“最派生对象”里到底有没有那个目标子对象；有就调整指针，没有就返回空。</strong></p><p>RTTI 的引入解决了多态层次下安全向下转型的问题，但也带来了性能开销（存储 type_info）和设计上的“味道”（频繁使用 RTTI 可能意味着设计模式有问题）。</p><h2 id="%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0" id="模板函数与虚函数">模板函数与虚函数 <a class="header-anchor" href="#%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0">#</a></h2><h3 id="todo%3A-%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" id="TODO-模板函数与虚函数，以及他们的汇编语言之间有什么区别">TODO: 模板函数与虚函数，以及他们的汇编语言之间有什么区别 <a class="header-anchor" href="#todo%3A-%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a></h3><p><strong>模板函数可以是虚函数吗？不可以。</strong></p><p>编译会报错：<code>templates may not be 'virtual'</code></p><p><strong>Why:</strong></p><p>虚函数机制依赖于固定的虚函数表（vtable）结构，而模板成员函数在实例化前无法确定其地址和数量。</p><p><strong>虚函数需要“运行时固定”的 vtable，而模板实例化是“编译期分散”的</strong>，两者在 ABI 层面无法同时满足。</p><h2 id="%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Astatic%2C-const%2C-enum-class" id="常用关键字：static-const-enum-class">常用关键字：static, const, enum class <a class="header-anchor" href="#%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Astatic%2C-const%2C-enum-class">#</a></h2><h3 id="static" id="static">static <a class="header-anchor" href="#static">#</a></h3><ul><li><strong>修饰非成员函数</strong>：内部链接属性，作用域限制在当前文件。</li><li><strong>修饰成员函数</strong>：属于类而非对象，<strong>编译时确定地址</strong>，<strong>无 <code>this</code> 指针</strong>，与多态和虚函数不沾边。</li></ul><h3 id="const" id="const">const <a class="header-anchor" href="#const">#</a></h3><ul><li><strong>修饰成员函数</strong>：限制修改类成员变量（除非 <code>mutable</code>）。<code>const</code> 对象只能调用 <code>const</code> 成员函数。</li></ul><h3 id="%E5%BC%BA%E7%B1%BB%E5%9E%8B%E6%9E%9A%E4%B8%BE-enum-class" id="强类型枚举-enum-class">强类型枚举 enum class <a class="header-anchor" href="#%E5%BC%BA%E7%B1%BB%E5%9E%8B%E6%9E%9A%E4%B8%BE-enum-class">#</a></h3><p><em>(待补充)</em></p><h3 id="lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F" id="lambda-表达式">lambda 表达式 <a class="header-anchor" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F">#</a></h3><p>lambda 表达式也可以用 namespace 匿名空间里的函数或 static 自由函数来替代，但 lambda 更拥抱现代 C++ 变化。</p><hr><h1>第四部分：内存管理与资源控制</h1><h2 id="%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9A%E5%A0%86%E4%B8%8E%E6%A0%88" id="内存模型：堆与栈">内存模型：堆与栈 <a class="header-anchor" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9A%E5%A0%86%E4%B8%8E%E6%A0%88">#</a></h2><table><thead><tr><th><strong>特性</strong></th><th><strong>栈 (Stack)</strong></th><th><strong>堆 (Heap)</strong></th></tr></thead><tbody><tr><td><strong>分配速度</strong></td><td>极快 (移动指针)</td><td>较慢 (系统调用, 查找内存块)</td></tr><tr><td><strong>管理方式</strong></td><td>自动 (编译器)</td><td>手动 (new/delete, malloc/free)</td></tr><tr><td><strong>空间大小</strong></td><td>小 (MB级)</td><td>大 (GB级)</td></tr><tr><td><strong>生命周期</strong></td><td>作用域内</td><td>手动控制</td></tr><tr><td><strong>内存连续性</strong></td><td>连续</td><td>可能不连续 (碎片)</td></tr></tbody></table><ul><li><strong>实际开发建议</strong>：优先使用栈。大数据或长生命周期数据用堆，且推荐使用智能指针。</li></ul><h2 id="raii-(resource-acquisition-is-initialization)" id="RAII-Resource-Acquisition-Is-Initialization">RAII (Resource Acquisition Is Initialization) <a class="header-anchor" href="#raii-(resource-acquisition-is-initialization)">#</a></h2><p>使用<strong>局部对象</strong>来<strong>管理资源</strong>的技术。</p><p><strong>RAII</strong> 充分利用了 C++ 语言<strong>局部对象自动销毁</strong>的特性来控制资源的生命周期。</p><p><strong>RAII 过程四步骤：</strong></p><ol><li>设计一个类封装资源</li><li>在构造函数中初始化</li><li>在析构函数中执行销毁操作</li><li>使用时声明一个该对象的类</li></ol><h2 id="%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-%26-std%3A%3Amemcpy-%2F-std%3A%3Amemmove" id="内存对齐-std-memcpy-std-memmove">内存对齐 &amp; std::memcpy / std::memmove <a class="header-anchor" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-%26-std%3A%3Amemcpy-%2F-std%3A%3Amemmove">#</a></h2><p><a href="https://zhuanlan.zhihu.com/p/30007037">C/C++ 内存对齐详解</a></p><p><em>(相关章节待补充)</em></p><h2 id="new%5B%5D%2C-delete%5B%5D" id="new-delete">new[], delete[] <a class="header-anchor" href="#new%5B%5D%2C-delete%5B%5D">#</a></h2><p><em>(相关章节待补充)</em></p><h2 id="std%3A%3Ashared_ptr" id="std-shared-ptr">std::shared_ptr <a class="header-anchor" href="#std%3A%3Ashared_ptr">#</a></h2><p><em>(相关章节待补充)</em></p><hr><h1>第五部分：并发编程 (C++11 Multi-threading)</h1><p>多线程是<strong>不确定的</strong>。</p><h2 id="std%3A%3Athread" id="std-thread">std::thread <a class="header-anchor" href="#std%3A%3Athread">#</a></h2><h3 id="%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8" id="基础使用">基础使用 <a class="header-anchor" href="#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8">#</a></h3><p>C++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::thread <span class="hljs-title">d2</span><span class="hljs-params">(download2)</span></span>; <span class="hljs-comment">// 开启线程</span><br><span class="hljs-comment">// ...</span><br>d<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>(); <span class="hljs-comment">// 等待线程结束</span><br></code></pre></td></tr></table></figure><h3 id="join()-vs-detach()" id="join-vs-detach">join() vs detach() <a class="header-anchor" href="#join()-vs-detach()">#</a></h3><ul><li><strong>join()</strong>: 阻塞调用线程，直到线程对象的方法执行完毕。</li><li><strong>detach()</strong>: 分离控制权，线程变成后台守护线程（daemon），由操作系统回收资源。</li></ul><p><strong>Best Practice</strong>: Always join or detach before exit.</p><h3 id="%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" id="线程对象生命周期">线程对象生命周期 <a class="header-anchor" href="#%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">#</a></h3><p>在退出 <code>std::thread</code> 对象的作用域之前，<strong>必须</strong>调用 <code>join()</code> 或 <code>detach()</code>。否则析构函数会调用 <code>std::terminate()</code> 终止程序。</p><p>这也是 <code>std::thread</code> 设计上的一个“陷阱”，破坏了 RAII 的自动性。实践中推荐使用 <code>jthread</code> (C++20) 或封装 <code>ThreadGuard</code>。</p><h2 id="%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E5%90%8C%E6%AD%A5" id="互斥锁与同步">互斥锁与同步 <a class="header-anchor" href="#%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E5%90%8C%E6%AD%A5">#</a></h2><ul><li><strong>std::mutex</strong>: 互斥锁。</li><li><strong>std::lock_guard</strong>: RAII 风格锁，构造锁定，析构解锁。</li><li><strong>std::unique_lock</strong>: 比 lock_guard 更灵活，支持延迟锁定、手动解锁、条件变量配合。</li></ul><p><strong>条件变量</strong>: <code>std::condition_variable</code>，配合 <code>std::unique_lock</code> 使用。</p><h3 id="std%3A%3Aasync%2C-std%3A%3Afuture" id="std-async-std-future">std::async, std::future <a class="header-anchor" href="#std%3A%3Aasync%2C-std%3A%3Afuture">#</a></h3><p><em>(相关章节待补充)</em></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试：RL算法笔记</title>
    <link href="/2026/02/08/hello/"/>
    <url>/2026/02/08/hello/</url>
    
    <content type="html"><![CDATA[<h2 id="%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E6%96%B0%E5%8D%9A%E5%AE%A2" id="欢迎来到我的新博客">欢迎来到我的新博客 <a class="header-anchor" href="#%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E6%96%B0%E5%8D%9A%E5%AE%A2">#</a></h2><p>这是模仿 hwcoder.top 风格搭建的 Hexo Fluid 博客。</p><h3 id="%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95" id="数学公式测试">数学公式测试 <a class="header-anchor" href="#%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95">#</a></h3><mjx-container class="MathJax" jax="SVG" display="true" style="direction: ltr; display: block; text-align: center; margin: 1em 0; position: relative;"><svg style="overflow: visible; min-height: 1px; min-width: 1px; vertical-align: -1.741ex;" xmlns="http://www.w3.org/2000/svg" width="50.246ex" height="3.571ex" role="img" focusable="false" viewBox="0 -809 22208.8 1578.4" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z" style="stroke-width: 3;"/></g><g data-mml-node="mo" transform="translate(791,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z" style="stroke-width: 3;"/></g><g data-mml-node="mi" transform="translate(1180,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z" style="stroke-width: 3;"/></g><g data-mml-node="mo" transform="translate(1649,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z" style="stroke-width: 3;"/></g><g data-mml-node="mi" transform="translate(2093.7,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z" style="stroke-width: 3;"/></g><g data-mml-node="mo" transform="translate(2622.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" style="stroke-width: 3;"/></g><g data-mml-node="mo" transform="translate(3289.4,0)"><path data-c="2190" d="M944 261T944 250T929 230H165Q167 228 182 216T211 189T244 152T277 96T303 25Q308 7 308 0Q308 -11 288 -11Q281 -11 278 -11T272 -7T267 2T263 21Q245 94 195 151T73 236Q58 242 55 247Q55 254 59 257T73 264Q121 283 158 314T215 375T247 434T264 480L267 497Q269 503 270 505T275 509T288 511Q308 511 308 500Q308 493 303 475Q293 438 278 406T246 352T215 315T185 287T165 270H929Q944 261 944 250Z" style="stroke-width: 3;"/></g><g data-mml-node="mi" transform="translate(4567.2,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z" style="stroke-width: 3;"/></g><g data-mml-node="mo" transform="translate(5358.2,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z" style="stroke-width: 3;"/></g><g data-mml-node="mi" transform="translate(5747.2,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z" style="stroke-width: 3;"/></g><g data-mml-node="mo" transform="translate(6216.2,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z" style="stroke-width: 3;"/></g><g data-mml-node="mi" transform="translate(6660.9,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z" style="stroke-width: 3;"/></g><g data-mml-node="mo" transform="translate(7189.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" style="stroke-width: 3;"/></g><g data-mml-node="mo" transform="translate(7801.1,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z" style="stroke-width: 3;"/></g><g data-mml-node="mi" transform="translate(8801.3,0)"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z" style="stroke-width: 3;"/></g><g data-mml-node="mo" transform="translate(9441.3,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z" style="stroke-width: 3;"/></g><g data-mml-node="mi" transform="translate(9719.3,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z" style="stroke-width: 3;"/></g><g data-mml-node="mo" transform="translate(10392.6,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z" style="stroke-width: 3;"/></g><g data-mml-node="mi" transform="translate(11392.8,0)"><path data-c="1D6FE" d="M31 249Q11 249 11 258Q11 275 26 304T66 365T129 418T206 441Q233 441 239 440Q287 429 318 386T371 255Q385 195 385 170Q385 166 386 166L398 193Q418 244 443 300T486 391T508 430Q510 431 524 431H537Q543 425 543 422Q543 418 522 378T463 251T391 71Q385 55 378 6T357 -100Q341 -165 330 -190T303 -216Q286 -216 286 -188Q286 -138 340 32L346 51L347 69Q348 79 348 100Q348 257 291 317Q251 355 196 355Q148 355 108 329T51 260Q49 251 47 251Q45 249 31 249Z" style="stroke-width: 3;"/></g><g data-mml-node="munder" transform="translate(12102.4,0)"><g data-mml-node="mo"><path data-c="6D" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q351 442 364 440T387 434T406 426T421 417T432 406T441 395T448 384T452 374T455 366L457 361L460 365Q463 369 466 373T475 384T488 397T503 410T523 422T546 432T572 439T603 442Q729 442 740 329Q741 322 741 190V104Q741 66 743 59T754 49Q775 46 803 46H819V0H811L788 1Q764 2 737 2T699 3Q596 3 587 0H579V46H595Q656 46 656 62Q657 64 657 200Q656 335 655 343Q649 371 635 385T611 402T585 404Q540 404 506 370Q479 343 472 315T464 232V168V108Q464 78 465 68T468 55T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" style="stroke-width: 3;"/><path data-c="61" d="M137 305T115 305T78 320T63 359Q63 394 97 421T218 448Q291 448 336 416T396 340Q401 326 401 309T402 194V124Q402 76 407 58T428 40Q443 40 448 56T453 109V145H493V106Q492 66 490 59Q481 29 455 12T400 -6T353 12T329 54V58L327 55Q325 52 322 49T314 40T302 29T287 17T269 6T247 -2T221 -8T190 -11Q130 -11 82 20T34 107Q34 128 41 147T68 188T116 225T194 253T304 268H318V290Q318 324 312 340Q290 411 215 411Q197 411 181 410T156 406T148 403Q170 388 170 359Q170 334 154 320ZM126 106Q126 75 150 51T209 26Q247 26 276 49T315 109Q317 116 318 175Q318 233 317 233Q309 233 296 232T251 223T193 203T147 166T126 106Z" transform="translate(833,0)" style="stroke-width: 3;"/><path data-c="78" d="M201 0Q189 3 102 3Q26 3 17 0H11V46H25Q48 47 67 52T96 61T121 78T139 96T160 122T180 150L226 210L168 288Q159 301 149 315T133 336T122 351T113 363T107 370T100 376T94 379T88 381T80 383Q74 383 44 385H16V431H23Q59 429 126 429Q219 429 229 431H237V385Q201 381 201 369Q201 367 211 353T239 315T268 274L272 270L297 304Q329 345 329 358Q329 364 327 369T322 376T317 380T310 384L307 385H302V431H309Q324 428 408 428Q487 428 493 431H499V385H492Q443 385 411 368Q394 360 377 341T312 257L296 236L358 151Q424 61 429 57T446 50Q464 46 499 46H516V0H510H502Q494 1 482 1T457 2T432 2T414 3Q403 3 377 3T327 1L304 0H295V46H298Q309 46 320 51T331 63Q331 65 291 120L250 175Q249 174 219 133T185 88Q181 83 181 74Q181 63 188 55T206 46Q208 46 208 23V0H201Z" transform="translate(1333,0)" style="stroke-width: 3;"/></g><g data-mml-node="TeXAtom" transform="translate(645.4,-662.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z" style="stroke-width: 3;"/></g><g data-mml-node="mo" transform="translate(562,289) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z" style="stroke-width: 3;"/></g></g></g></g><g data-mml-node="mi" transform="translate(14130.1,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z" style="stroke-width: 3;"/></g><g data-mml-node="mo" transform="translate(14921.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z" style="stroke-width: 3;"/></g><g data-mml-node="msup" transform="translate(15310.1,0)"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z" style="stroke-width: 3;"/></g><g data-mml-node="mo" transform="translate(502,413) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z" style="stroke-width: 3;"/></g></g><g data-mml-node="mo" transform="translate(16056.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z" style="stroke-width: 3;"/></g><g data-mml-node="msup" transform="translate(16501.2,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z" style="stroke-width: 3;"/></g><g data-mml-node="mo" transform="translate(562,413) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z" style="stroke-width: 3;"/></g></g><g data-mml-node="mo" transform="translate(17307.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" style="stroke-width: 3;"/></g><g data-mml-node="mo" transform="translate(17918.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" style="stroke-width: 3;"/></g><g data-mml-node="mi" transform="translate(18919.1,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z" style="stroke-width: 3;"/></g><g data-mml-node="mo" transform="translate(19710.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z" style="stroke-width: 3;"/></g><g data-mml-node="mi" transform="translate(20099.1,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z" style="stroke-width: 3;"/></g><g data-mml-node="mo" transform="translate(20568.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z" style="stroke-width: 3;"/></g><g data-mml-node="mi" transform="translate(21012.8,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z" style="stroke-width: 3;"/></g><g data-mml-node="mo" transform="translate(21541.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" style="stroke-width: 3;"/></g><g data-mml-node="mo" transform="translate(21930.8,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z" style="stroke-width: 3;"/></g></g></g></svg><mjx-assistive-mml unselectable="on" display="block" style="top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; position: absolute; padding: 1px 0px 0px 0px; border: 0px; display: block; overflow: hidden; width: 100%;"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>Q</mi><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">←</mo><mi>Q</mi><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>+</mo><mi>α</mi><mo stretchy="false">[</mo><mi>r</mi><mo>+</mo><mi>γ</mi><munder><mo data-mjx-texclass="OP" movablelimits="true">max</mo><mrow data-mjx-texclass="ORD"><msup><mi>a</mi><mo data-mjx-alternate="1">′</mo></msup></mrow></munder><mi>Q</mi><mo stretchy="false">(</mo><msup><mi>s</mi><mo data-mjx-alternate="1">′</mo></msup><mo>,</mo><msup><mi>a</mi><mo data-mjx-alternate="1">′</mo></msup><mo stretchy="false">)</mo><mo>−</mo><mi>Q</mi><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></math></mjx-assistive-mml></mjx-container><h3 id="%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E6%B5%8B%E8%AF%95" id="代码高亮测试">代码高亮测试 <a class="header-anchor" href="#%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E6%B5%8B%E8%AF%95">#</a></h3><pre><code class="language-cpp">#include &lt;iostream&gt;int main() &#123;    std::cout &lt;&lt; &quot;Hello Robotics!&quot; &lt;&lt; std::endl;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Reinforcement Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

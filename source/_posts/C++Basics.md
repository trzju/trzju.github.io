---
title: C++ 核心机制深度解析：从对象模型到并发实践
date: 2026-02-09
tags: [C++, Engineering, Notes]
---

# 前言

本文涵盖了 C++ 学习过程中的核心知识点整理，包括拷贝控制、多态的底层实现、内存管理细节以及多线程编程的基础。部分章节仍需补充（标记为 TODO），作为后续深入学习的索引。

---

# 第一部分：对象生命周期与特殊成员函数

## 拷贝构造、赋值构造与对象切片

在 C++ 中，**拷贝构造函数（Copy Constructor）** 和 **赋值构造函数（Copy Assignment Operator）** 都是用于对象复制的特殊成员函数，但它们的使用场景和语义不同，容易混淆。

✅ 一句话区分：

| 场景 | 调用函数 |
| :--- | :--- |
| 用一个已有对象**初始化一个新对象** | **拷贝构造函数** |
| 用一个已有对象**给另一个已存在的对象赋值** | **赋值构造函数（赋值运算符）** |

### 一、拷贝构造函数（Copy Constructor）

📌 定义格式：

```cpp
ClassName(const ClassName& other);
```

必须用引用传参，不可以用值传递**（防止递归引用）**

📌 触发时机：

- 用一个对象初始化另一个新对象时：

  C++

  ```
  MyClass a;
  MyClass b = a;        // ✅ 拷贝构造
  MyClass c(a);         // ✅ 拷贝构造
  ```

- 函数传参**按值传递**时：

  C++

  ```
  void foo(MyClass obj); // ✅ 调用拷贝构造
  ```

- 函数返回对象**按值返回**时（未优化前）：

  C++

  ```
  MyClass create() {
      MyClass temp;
      return temp; // ✅ 可能调用拷贝构造（NRVO 可能优化掉）
  }
  ```

#### TODO：深拷贝与浅拷贝，默认拷贝构造函数-对象的动态成员

### 二、赋值构造函数（Copy Assignment Operator）

📌 定义格式：

C++

```
ClassName& operator=(const ClassName& other);
```

📌 触发时机：

- 用一个已有对象给另一个**已存在的对象**赋值时：

  C++

  ```
  MyClass a;
  MyClass b;
  b = a; // ✅ 调用赋值运算符
  ```

### 三、对比总结表

| **特性** | **拷贝构造函数**              | **赋值运算符**                           |
| -------- | ----------------------------- | ---------------------------------------- |
| 用途     | 初始化新对象                  | 给已有对象赋值                           |
| 形式     | `ClassName(const ClassName&)` | `ClassName& operator=(const ClassName&)` |
| 触发     | 初始化、传值、返回值          | 赋值操作                                 |
| 返回值   | 无（构造函数）                | `*this`（支持链式赋值）                  |

------

### 四、示例代码对比

C++

```
#include <iostream>
using namespace std;

class MyClass {
public:
    int value;

    // 构造函数
    MyClass(int v = 0) : value(v) {
        cout << "Constructor\n";
    }

    // 拷贝构造函数
    MyClass(const MyClass& other) : value(other.value) {
        cout << "Copy Constructor\n";
    }

    // 赋值运算符
    MyClass& operator=(const MyClass& other) {
        if (this != &other) {
            value = other.value;
            cout << "Copy Assignment Operator\n";
        }
        return *this;
    }
};

int main() {
    MyClass a(10);     // Constructor
    MyClass b = a;     // Copy Constructor（初始化）
    MyClass c;
    c = a;             // Copy Assignment Operator（赋值）
}
```

✅ 输出：

```
Constructor
Copy Constructor
Constructor
Copy Assignment Operator
```

- 如果你定义了**析构函数、拷贝构造、拷贝赋值**中的一个，**建议三者都定义**（Rule of Three）。
- C++11 起，还有**移动构造函数**和**移动赋值运算符**（Rule of Five）。

## 深拷贝、浅拷贝与拷贝构造、赋值构造

*(此处待补充)*

## 对象切片 (Object Slicing)

**拷贝构造/赋值构造与多态之间**并不是“协同工作”的关系，而是**存在潜在冲突**的。

**它们默认都是“非虚”的，一旦用于多态场景，就会把对象切成“基类子对象”，从而丢失派生类信息——这几乎总是 bug**。

[深入理解C++对象切片（Object Slicing）：从 benign bug 到 dangerous corruption](https://juejin.cn/post/7547891478565011508)

C++ Primer 第5版 15.2.3 ……在对象之间不存在类型转换 page.535

**TODO**

> 关于对象切片 我的理解：根本就是因为C++的默认拷贝/赋值/移动 构造函数是**非虚**的，是不支持多态的，是静态绑定而非运行时动态绑定的。
>
> 始终牢记C++默认采用静态绑定和非虚赋值操作，并通过使用指针、引用、智能指针和谨慎的类设计来规避这一陷阱。

### 警惕标准库容器

将派生类对象直接存入`std::vector<Base>`会发生**切片**。

正确做法是使用`std::vector<std::unique_ptr<Base>>`。

------

# 第二部分：深入多态与继承

## 构造与析构，继承与多态

### 1. 构造顺序

构造的顺序永远是从基类到派生类逐级构造，这是语法规则，与多态无关。

> **对象构造的完整流程**：
>
> 1. **分配对象内存**
> 2. **执行父类构造（如果有）**
> 3. **执行成员初始化列表 - 按声明顺序初始化所有成员 - 未在列表中的成员使用默认初始化**
> 4. **执行构造函数体**

#### 初始化列表：

初始化列表并不决定各成员变量的初始化顺序，实际的初始化顺序由成员变量的声明顺序决定。因此初始化列表的顺序最好保持与声明顺序一致。

**初始化≠赋值**：初始化列表是真正的初始化，构造函数体内是赋值。

无论是否有初始化列表、无论成员变量是否在初始化列表中，都会在进入构造函数体前进行初始化。

——**因此**：存在以下四种必须使用初始化列表的情况：`const`成员变量；引用成员变量；没有默认构造函数的类成员；父类构造函数调用。

**在C++中，初始化总是优于赋值**，对于类类型，直接初始化比默认构造+赋值更高效、更快。

> **最佳实践：**
>
> 1. **总是使用初始化列表**
> 2. **保持初始化顺序与声明顺序一致**
> 3. **基本类型也要初始化**

#### **构造顺序是静态规则**。

因为派生类的对象里“包含”一个基类子对象，必须先构造好基类部分，才能继续构造派生类部分。

编译器在派生类构造函数体执行之前自动插入基类构造函数的调用。

编译器会在派生类构造函数的**初始化阶段**（而非构造函数体内部的开头）自动插入基类构造函数的调用代码。

C++ 语言规则强制要求：**派生类对象的构造必须先初始化其继承的基类部分，再初始化派生类自身的成员和构造函数体**。这一规则由编译器通过以下方式在编译时落实：

1. **隐式调用场景**：如果派生类构造函数没有显式指定基类构造函数（即初始化列表中未写基类名），编译器会自动插入**基类的默认构造函数（无参构造）** 调用，且该调用发生在：
   - 派生类自身成员的初始化之前；
   - 派生类构造函数体执行之前。
2. **显式调用场景**：如果派生类构造函数在**初始化列表**中显式指定了基类构造函数（含带参构造），编译器会按指定的构造函数调用，且顺序仍优先于派生类成员初始化和构造函数体。

构造函数的执行分为两个阶段：

- **初始化阶段**：先执行基类构造 → 再执行派生类成员的初始化（按成员声明顺序，而非初始化列表顺序）；
- **函数体阶段**：执行派生类构造函数体内的代码。

编译器的处理是：在**初始化阶段**的最开始，自动生成基类构造函数的调用代码（隐式或显式），而非修改构造函数体。

#### -->> 所以如果基类没有默认构造函数（仅含带参构造），且派生类未显式调用基类带参构造，**编译会直接报错**， 这进一步证明基类构造的调用是编译期强制检查和处理的

### 2. 基类虚析构与多态

首先，**语言规定**：无论析构函数从哪一层开始执行，必须保证所有基类的析构函数也被调用

当基类的析构函数为virtual时，`delete base_ptr`触发**动态绑定**，运行时根据实际的**对象**类型找到对应的析构函数。

即**virtual**决定了从哪一层开始析构。

析构的执行顺序：**派生类析构函数体 → 派生类自身\*成员\*的析构 → 基类析构函数体**

编译派生类析构函数时，编译器会在其 **“清理阶段”**（派生类析构函数体执行完毕后），自动插入基类析构函数的调用代码 —— 无需手动编写 `Base::~Base()`，编译期已确定这一调用逻辑（类似构造函数，但顺序相反）。

#### Why virtual destructor

虚函数是C++多态的实现，没有虚函数就没有多态。

那么基类的析构函数不是虚析构时，在析构子类时就无法实现**多态**，即无法正确地先调用子类析构再调用基类析构，而是直接调用基类析构，导致子类资源未正确释放。

*(此处省略原笔记中的代码示例，保留原意)*

> **结论**：将基类的析构函数定义为虚函数后，`delete base_ptr` 才能得到正确的运行结果（先派生类析构，后基类析构）。

#### 虚析构函数的工程实践

在工程实践中，C++ 的虚析构函数是一条**“只要类可能被继承，就默认应声明为虚”**的防御性编程铁律。它的核心目的不是“为了多态调用”，而是**“为了在用户通过基类指针 delete 派生对象时，能够按构造逆序完整执行整条析构链，避免资源泄漏+未定义行为”**。

**工业级代码套路：**

1. **基类模板**：声明 `virtual ~Base() = default;` 并禁用拷贝（防止切片）。
2. **抽象接口**：声明纯虚析构 `virtual ~ILogger() = 0;` 并在 .cpp 给出空实现。
3. **工程规范**：“凡是设计为被继承的类，立即把析构函数声明为 `virtual`（或纯虚 + 定义），并关闭拷贝；否则就在类注释里写 ‘本类禁止继承’ 并加 `final`。”

### 3. 虚继承，多重继承

首先是**多继承**可能带来的问题（要我说就不应该写多继承）：

比如菱形继承，很可能导致命名冲突、冗余数据等问题。

为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。

C++标准库中的 `iostream` 类就是一个虚继承的实际应用案例（继承自 `istream` 和 `ostream`，它们又共同继承自 `base_ios`）。

## 详说继承与多态

什么是多态？OOP的核心思想就是多态性。

**OOP-派生类与继承类之间的类型转换**：使用动态绑定（运行时绑定），可以在一定程度上忽略相似类型的区别，而以统一的方式使用他们的对象。——这也是为什么要使用基类指针、引用来操作派生类对象。

### Why override

`override` 是 C++11 引入的一个上下文关键字，用于**显式地**指出一个成员函数是重写基类的虚函数。它的作用是**帮助编译器检查是否真的重写了基类的虚函数**，从而避免因为拼写错误、参数列表不一致等问题导致的“**隐藏**”而非“**重写**”的情况。

Simple as that!

> **override关键字不可以用于重写基类的普通成员函数**。在 C++ 中，`override` **只能用于重写基类的虚函数（`virtual`）**。

### 虚函数表

基类的虚函数和派生类的对应虚函数一定在虚函数表里槽号相等。

虚函数表是一个“**以基类为模板**”的线性数组。

- 编译器先给基类 `Base` 生成一张表，按**声明顺序**把每个虚函数地址依次放进槽 0、1、2…
- 再给派生类 `Derived` 生成一张表，**先逐字复制基类那张表**（保持槽号不变），然后把**被重写的那几项就地覆盖**成 `Derived` 的新地址；新增虚函数往后追加。

多态的实现：**对象里取 vptr → 查类虚表 → 得到最终函数地址**。

### 纯虚函数与抽象类

只要类中有一个纯虚函数，它就是抽象类，不能被实例化。即使是只有析构函数被定义为纯虚函数也是抽象类。（纯析构函数比较特殊，必须提供定义--**可以是空实现**）

### 函数重载、隐藏与覆盖

1. **重载 (Overload)**：同一作用域，同名不同参。
2. **隐藏 (Hiding)**：
   - 派生类定义了与基类同名的成员（无论参数是否一致），基类成员被隐藏。
   - **警惕**：如果派生类 `override` 的虚函数参数列表与基类不同，那么**不能构成** `override`，而是构成了**隐藏**。
3. **覆盖 (Override)**：派生类重写基类的虚函数，签名必须完全匹配。

*(关于名字查找与继承的详细解析，见原文档中的“函数调用的解析过程”章节)*

------

# 第三部分：高级语言特性 (RTTI, Template, Keywords)

## RTTI (Run-Time Type Identification)

C++有3个支持RTTI的元素：

1. `dynamic_cast`：安全地将基类指针转换为派生类指针（如果失败返回0/nullptr）。
2. `typeid`：返回对象的类型信息。
3. `type_info`：存储类型信息。

⚠️**RTTI只适用于包含虚函数的类**。

### dynamic_cast 机制

**交叉转换是否成功，取决于“最派生对象”里到底有没有那个目标子对象；有就调整指针，没有就返回空。**

RTTI 的引入解决了多态层次下安全向下转型的问题，但也带来了性能开销（存储 type_info）和设计上的“味道”（频繁使用 RTTI 可能意味着设计模式有问题）。

## 模板函数与虚函数

### TODO: 模板函数与虚函数，以及他们的汇编语言之间有什么区别

**模板函数可以是虚函数吗？不可以。**

编译会报错：`templates may not be 'virtual'`

**Why:**

虚函数机制依赖于固定的虚函数表（vtable）结构，而模板成员函数在实例化前无法确定其地址和数量。

**虚函数需要“运行时固定”的 vtable，而模板实例化是“编译期分散”的**，两者在 ABI 层面无法同时满足。

## 常用关键字：static, const, enum class

### static

- **修饰非成员函数**：内部链接属性，作用域限制在当前文件。
- **修饰成员函数**：属于类而非对象，**编译时确定地址**，**无 `this` 指针**，与多态和虚函数不沾边。

### const

- **修饰成员函数**：限制修改类成员变量（除非 `mutable`）。`const` 对象只能调用 `const` 成员函数。

### 强类型枚举 enum class

*(待补充)*

### lambda 表达式

lambda 表达式也可以用 namespace 匿名空间里的函数或 static 自由函数来替代，但 lambda 更拥抱现代 C++ 变化。

------

# 第四部分：内存管理与资源控制

## 内存模型：堆与栈

| **特性**       | **栈 (Stack)**  | **堆 (Heap)**                  |
| -------------- | --------------- | ------------------------------ |
| **分配速度**   | 极快 (移动指针) | 较慢 (系统调用, 查找内存块)    |
| **管理方式**   | 自动 (编译器)   | 手动 (new/delete, malloc/free) |
| **空间大小**   | 小 (MB级)       | 大 (GB级)                      |
| **生命周期**   | 作用域内        | 手动控制                       |
| **内存连续性** | 连续            | 可能不连续 (碎片)              |

- **实际开发建议**：优先使用栈。大数据或长生命周期数据用堆，且推荐使用智能指针。

## RAII (Resource Acquisition Is Initialization)

使用**局部对象**来**管理资源**的技术。

**RAII** 充分利用了 C++ 语言**局部对象自动销毁**的特性来控制资源的生命周期。

**RAII 过程四步骤：**

1. 设计一个类封装资源
2. 在构造函数中初始化
3. 在析构函数中执行销毁操作
4. 使用时声明一个该对象的类

## 内存对齐 & std::memcpy / std::memmove

[C/C++ 内存对齐详解](https://zhuanlan.zhihu.com/p/30007037)

*(相关章节待补充)*

## new[], delete[]

*(相关章节待补充)*

## std::shared_ptr

*(相关章节待补充)*

------

# 第五部分：并发编程 (C++11 Multi-threading)

多线程是**不确定的**。

## std::thread

### 基础使用

C++

```
std::thread d2(download2); // 开启线程
// ...
d2.join(); // 等待线程结束
```

### join() vs detach()

- **join()**: 阻塞调用线程，直到线程对象的方法执行完毕。
- **detach()**: 分离控制权，线程变成后台守护线程（daemon），由操作系统回收资源。

**Best Practice**: Always join or detach before exit.

### 线程对象生命周期

在退出 `std::thread` 对象的作用域之前，**必须**调用 `join()` 或 `detach()`。否则析构函数会调用 `std::terminate()` 终止程序。

这也是 `std::thread` 设计上的一个“陷阱”，破坏了 RAII 的自动性。实践中推荐使用 `jthread` (C++20) 或封装 `ThreadGuard`。

## 互斥锁与同步

- **std::mutex**: 互斥锁。
- **std::lock_guard**: RAII 风格锁，构造锁定，析构解锁。
- **std::unique_lock**: 比 lock_guard 更灵活，支持延迟锁定、手动解锁、条件变量配合。

**条件变量**: `std::condition_variable`，配合 `std::unique_lock` 使用。

### std::async, std::future

*(相关章节待补充)*

